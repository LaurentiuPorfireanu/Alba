<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Security AI Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            min-height: 100vh;
        }

        .header {
            background: rgba(0, 0, 0, 0.2);
            padding: 20px;
            text-align: center;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .subtitle {
            font-size: 1.2em;
            opacity: 0.8;
        }

        .tab-container {
            background: rgba(0, 0, 0, 0.2);
            padding: 0;
            margin: 0;
        }

        .tab-nav {
            display: flex;
            justify-content: center;
            background: transparent;
        }

        .tab-button {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            padding: 15px 30px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
        }

        .tab-button:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .tab-button.active {
            background: rgba(255, 255, 255, 0.3);
            border-bottom: 3px solid #74b9ff;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .panel h3 {
            margin-bottom: 15px;
            color: #fff;
            font-size: 1.3em;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 10px;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }

        .btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .btn.success {
            background: linear-gradient(45deg, #00b894, #00a085);
        }

        .btn.warning {
            background: linear-gradient(45deg, #fdcb6e, #e17055);
        }

        .btn.info {
            background: linear-gradient(45deg, #74b9ff, #0984e3);
        }

        .btn.training {
            background: linear-gradient(45deg, #fdcb6e, #f39c12);
        }

        .btn.testing {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }

        .mode-indicator {
            text-align: center;
            padding: 15px;
            margin: 20px 0;
            border-radius: 10px;
            font-weight: bold;
            font-size: 1.2em;
        }

        .mode-training {
            background: rgba(253, 203, 110, 0.2);
            border: 2px solid #fdcb6e;
            color: #fdcb6e;
        }

        .mode-testing {
            background: rgba(231, 76, 60, 0.2);
            border: 2px solid #e74c3c;
            color: #e74c3c;
        }

        .mode-idle {
            background: rgba(116, 185, 255, 0.2);
            border: 2px solid #74b9ff;
            color: #74b9ff;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-active {
            background: #00b894;
            box-shadow: 0 0 10px #00b894;
        }

        .status-inactive {
            background: #636e72;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #74b9ff;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 5px;
        }

        .log-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .log-entry {
            margin-bottom: 8px;
            padding: 5px;
            border-radius: 5px;
        }

        .log-normal {
            background: rgba(116, 185, 255, 0.1);
        }

        .log-warning {
            background: rgba(253, 203, 110, 0.2);
        }

        .log-danger {
            background: rgba(255, 107, 107, 0.2);
        }

        .chart-container {
            height: 300px;
            margin-top: 15px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
            margin: 0 10px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: 0.4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: #00b894;
        }

        input:checked+.slider:before {
            transform: translateX(26px);
        }

        .progress-bar {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            height: 20px;
            margin: 10px 0;
            overflow: hidden;
        }

        .progress-fill {
            background: linear-gradient(45deg, #74b9ff, #0984e3);
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .training-section {
            border: 2px solid rgba(253, 203, 110, 0.3);
            background: rgba(253, 203, 110, 0.1);
        }

        .testing-section {
            border: 2px solid rgba(231, 76, 60, 0.3);
            background: rgba(231, 76, 60, 0.1);
        }

        .blocked-ip-item {
            background: rgba(255, 107, 107, 0.2);
            border: 1px solid rgba(255, 107, 107, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin: 8px 0;
        }

        .blocked-ip-header {
            font-weight: bold;
            color: #ff6b6b;
            margin-bottom: 5px;
        }

        .blocked-ip-reason {
            font-size: 0.9em;
            margin-bottom: 3px;
        }

        .blocked-ip-time {
            font-size: 0.8em;
            opacity: 0.7;
        }

        .blocked-list {
            max-height: 300px;
            overflow-y: auto;
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>Network Security AI System</h1>
        <p class="subtitle">AI-Powered Network Security Training & Testing Platform</p>
    </div>

    <div class="tab-container">
        <div class="tab-nav">
            <button class="tab-button active" onclick="switchTab('training')">üéì Training Mode</button>
            <button class="tab-button" onclick="switchTab('testing')">üõ°Ô∏è Testing Mode</button>
            <button class="tab-button" onclick="switchTab('monitoring')">üìä Monitoring</button>
        </div>
    </div>

    <div id="modeIndicator" class="mode-indicator mode-idle">
        ü§ñ System Ready - Select Training or Testing Mode
    </div>

    <!-- Training Tab -->
    <div id="training" class="tab-content active">
        <div class="dashboard">
            <div class="panel training-section">
                <h3>üéì AI Training Center</h3>
                <p style="opacity: 0.8; margin-bottom: 15px;">Train AI models using synthetic data and real network
                    patterns</p>

                <div class="controls">
                    <button class="btn training" onclick="startContinuousTraining()">Start Continuous Training</button>
                    <button class="btn warning" onclick="stopTraining()">Stop Training</button>
                    <button class="btn success" onclick="saveAIModels()">Save Models</button>
                </div>

                <div id="trainingProgress" class="progress-bar" style="display: none;">
                    <div class="progress-fill" id="trainingProgressFill"></div>
                </div>

                <div id="trainingStatus" style="margin: 10px 0; font-weight: bold;">
                    Status: Ready for training
                </div>
                <div id="trainingSamples" style="font-size: 0.9em; opacity: 0.8;">
                    Training Samples: 0
                </div>
            </div>

            <div class="panel">
                <h3>üìä Training Data Generator</h3>
                <div class="controls">
                    <button class="btn info" onclick="generateTrainingData('normal')">Generate Normal Traffic</button>
                    <button class="btn warning" onclick="generateTrainingData('attack')">Generate Attack Data</button>
                    <button class="btn" onclick="generateTrainingData('mixed')">Generate Mixed Dataset</button>
                </div>

                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="normalSamples">0</div>
                        <div class="stat-label">Normal Samples</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="attackSamples">0</div>
                        <div class="stat-label">Attack Samples</div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>üéØ Model Performance</h3>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="modelAccuracy">0%</div>
                        <div class="stat-label">Accuracy</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="trainingEpochs">0</div>
                        <div class="stat-label">Epochs</div>
                    </div>
                </div>

                <div class="chart-container" id="trainingChart"></div>
            </div>

            <div class="panel">
                <h3>üìù Training Logs</h3>
                <div class="log-container" id="trainingLog">
                    <div class="log-entry log-normal">Training system initialized...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Testing Tab -->
    <div id="testing" class="tab-content">
        <div class="dashboard">
            <div class="panel testing-section">
                <h3>üõ°Ô∏è Defense Testing Center</h3>
                <p style="opacity: 0.8; margin-bottom: 15px;">Test trained AI models against simulated attacks</p>

                <div class="controls">
                    <button class="btn testing" id="enableTestingBtn" onclick="enableTesting()">Enable Testing
                        Mode</button>
                    <button class="btn warning" id="disableTestingBtn" onclick="disableTesting()"
                        style="display: none;">Disable Testing</button>
                    <button class="btn" onclick="resetTestResults()">Reset Results</button>
                </div>

                <div style="margin: 15px 0;">
                    <label>
                        Auto Attack Simulation:
                        <div class="toggle-switch">
                            <input type="checkbox" id="autoAttackToggle" onchange="toggleAutoAttack()">
                            <span class="slider"></span>
                        </div>
                    </label>
                </div>

                <div id="testingStatus" style="margin: 10px 0; font-weight: bold;">
                    Status: Testing mode disabled
                </div>
            </div>

            <div class="panel">
                <h3>‚öîÔ∏è Attack Simulator</h3>
                <div class="controls">
                    <button class="btn testing" onclick="launchAttack('DDoS')">DDoS Attack</button>
                    <button class="btn testing" onclick="launchAttack('Port Scan')">Port Scan</button>
                    <button class="btn testing" onclick="launchAttack('Brute Force')">Brute Force</button>
                    <button class="btn testing" onclick="launchAttack('SQL Injection')">SQL Injection</button>
                </div>
                <div class="controls">
                    <button class="btn testing" onclick="launchAttack('XSS')">XSS Attack</button>
                    <button class="btn testing" onclick="launchAttack('Malware')">Malware</button>
                    <button class="btn testing" onclick="launchAttack('Phishing')">Phishing</button>
                    <button class="btn testing" onclick="launchAttack('Man-in-Middle')">Man-in-Middle</button>
                </div>
                <div class="controls">
                    <button class="btn testing" onclick="launchAttack()">Random Attack</button>
                </div>

                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="totalAttacks">0</div>
                        <div class="stat-label">Total Attacks</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="lastAttackType">None</div>
                        <div class="stat-label">Last Attack</div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>üõ°Ô∏è Defense Results</h3>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="blockedAttacks">0</div>
                        <div class="stat-label">Blocked Attacks</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="detectionRate">0%</div>
                        <div class="stat-label">Detection Rate</div>
                    </div>
                </div>

                <div class="log-container" id="defenseLog">
                    <div class="log-entry log-normal">Defense system ready...</div>
                </div>
            </div>

            <div class="panel">
                <h3>üìà Testing Analysis</h3>
                <div class="chart-container" id="testingChart"></div>
            </div>
        </div>
    </div>

    <!-- Monitoring Tab -->
    <div id="monitoring" class="tab-content">
        <div class="dashboard">
            <div class="panel">
                <h3>üîß System Control</h3>
                <div class="controls">
                    <button class="btn success" onclick="startMonitoring()">Start Monitor</button>
                    <button class="btn warning" onclick="stopMonitoring()">Stop Monitor</button>
                    <button class="btn" onclick="resetSystem()">Reset System</button>
                </div>

                <div style="margin: 15px 0;">
                    <label>
                        <span class="status-indicator" id="monitorStatus"></span>
                        Network Monitoring
                    </label>
                </div>
            </div>

            <div class="panel">
                <h3>üö´ Blocked IPs</h3>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="totalBlockedIPs">0</div>
                        <div class="stat-label">Total Blocked</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="recentBlocks">0</div>
                        <div class="stat-label">Recent Blocks</div>
                    </div>
                </div>

                <div class="blocked-list" id="blockedIPsList">
                    <div class="log-entry log-normal">No blocked IPs...</div>
                </div>
            </div>

            <div class="panel">
                <h3>üìã System Activity</h3>
                <div class="log-container" id="systemLog">
                    <div class="log-entry log-normal">System started successfully...</div>
                </div>
            </div>

            <div class="panel">
                <h3>üìä Network Statistics</h3>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="totalPackets">0</div>
                        <div class="stat-label">Total Packets</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="anomalies">0</div>
                        <div class="stat-label">Anomalies</div>
                    </div>
                </div>
                <div class="chart-container" id="systemStatsChart"></div>
            </div>
        </div>
    </div>

    <script>
        let currentTab = 'training';
        let updateInterval;
        let anomalyCount = 0;
        let testingActive = false;
        let trainingActive = false;
        let trainingData = {
            epochs: [],
            accuracy: [],
            loss: []
        };

        // SHARED DATA - synchronized between testing and monitoring
        let sharedBlockedIPs = {
            total: 0,
            recent: 0,
            list: []
        };

        // Tab Management
        function switchTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });

            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });

            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');

            currentTab = tabName;
            updateModeIndicator();

            // Clear and update stats when switching tabs
            if (tabName === 'testing') {
                updateTestingStats();
                updateTestingChart();
                // Sync blocked IPs immediately when switching to testing
                syncBlockedIPsDisplay();
            } else if (tabName === 'training') {
                updateTrainingStats();
            } else if (tabName === 'monitoring') {
                updateMonitoringStats();
                updateBlockedIPs();
                // Sync blocked IPs immediately when switching to monitoring
                syncBlockedIPsDisplay();
            }
        }

        // SYNC FUNCTION: Keep blocked IPs synchronized between testing and monitoring
        function syncBlockedIPsDisplay() {
            fetch('/api/blocked_ips')
                .then(response => response.json())
                .then(data => {
                    // Update shared blocked IPs data
                    sharedBlockedIPs.total = data.total_blocked;
                    sharedBlockedIPs.list = data.blocked_ips;

                    // Calculate recent blocks (last 5)
                    sharedBlockedIPs.recent = Math.min(5, data.blocked_ips.length);

                    // Update both testing and monitoring displays with same data
                    updateBlockedIPsInTesting(data);
                    updateBlockedIPsInMonitoring(data);
                })
                .catch(error => {
                    console.log('Blocked IPs sync failed:', error);
                });
        }

        function updateBlockedIPsInTesting(data) {
            // Update testing tab if elements exist
            const testingBlockedElement = document.getElementById('blockedAttacks');
            if (testingBlockedElement && testingActive) {
                // In testing mode, show actual blocked count from defense system
                testingBlockedElement.textContent = data.total_blocked;
            }
        }

        function updateBlockedIPsInMonitoring(data) {
            // Update monitoring tab elements
            const totalBlockedElement = document.getElementById('totalBlockedIPs');
            const recentBlocksElement = document.getElementById('recentBlocks');
            const blockedListElement = document.getElementById('blockedIPsList');

            if (totalBlockedElement) {
                totalBlockedElement.textContent = data.total_blocked;
            }

            if (recentBlocksElement) {
                recentBlocksElement.textContent = sharedBlockedIPs.recent;
            }

            if (blockedListElement) {
                if (data.blocked_ips.length === 0) {
                    blockedListElement.innerHTML = '<div class="log-entry log-normal">No blocked IPs...</div>';
                } else {
                    blockedListElement.innerHTML = '';

                    // Sort by timestamp (most recent first)
                    const sortedIPs = data.blocked_ips.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

                    sortedIPs.forEach(blockedIP => {
                        const ipDiv = document.createElement('div');
                        ipDiv.className = 'blocked-ip-item';

                        const time = new Date(blockedIP.timestamp).toLocaleString();

                        ipDiv.innerHTML = `
                            <div class="blocked-ip-header">üö´ ${blockedIP.ip}</div>
                            <div class="blocked-ip-reason">${blockedIP.reason}</div>
                            <div class="blocked-ip-time">Blocked: ${time}</div>
                            <div class="blocked-ip-time">Threat Level: ${blockedIP.threat_level} (${(blockedIP.confidence * 100).toFixed(1)}%)</div>
                        `;

                        blockedListElement.appendChild(ipDiv);
                    });
                }
            }
        }

        function updateModeIndicator() {
            const indicator = document.getElementById('modeIndicator');

            if (trainingActive) {
                indicator.className = 'mode-indicator mode-training';
                indicator.innerHTML = 'üéì Training Mode Active - AI Learning in Progress';
            } else if (testingActive) {
                indicator.className = 'mode-indicator mode-testing';
                indicator.innerHTML = 'üõ°Ô∏è Testing Mode Active - Defense Systems Online';
            } else if (currentTab === 'training') {
                indicator.className = 'mode-indicator mode-idle';
                indicator.innerHTML = 'üéì Training Mode Ready - Configure AI Training';
            } else if (currentTab === 'testing') {
                indicator.className = 'mode-indicator mode-idle';
                indicator.innerHTML = 'üõ°Ô∏è Testing Mode Ready - Load Trained Models';
            } else {
                indicator.className = 'mode-indicator mode-idle';
                indicator.innerHTML = 'üìä Monitoring Mode - System Observation';
            }
        }

        // Training Functions
        function startContinuousTraining() {
            if (testingActive) {
                alert('Cannot start training while testing mode is active!');
                return;
            }

            trainingActive = true;
            updateModeIndicator();

            document.getElementById('trainingStatus').innerHTML = 'Status: <span style="color: #fdcb6e;">Continuous Training Active...</span>';
            document.getElementById('trainingProgress').style.display = 'block';

            fetch('/api/continuous_training', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: true })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        addLogEntry('trainingLog', 'Continuous training started...', 'normal');
                        startTrainingProgressSimulation();
                    } else {
                        trainingActive = false;
                        updateModeIndicator();
                        addLogEntry('trainingLog', `Training error: ${data.message}`, 'danger');
                    }
                });
        }

        function stopTraining() {
            // ADAUGƒÇ ACESTE LINII:
            console.log("=== √éNAINTE DE STOP ===");
            console.log("Accuracy afi»ôatƒÉ:", document.getElementById('modelAccuracy').textContent);
            console.log("Epochs afi»ôate:", document.getElementById('trainingEpochs').textContent);

            trainingActive = false;
            updateModeIndicator();

            fetch('/api/continuous_training', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: false })
            })
                .then(response => response.json())
                .then(data => {
                    // ADAUGƒÇ ACESTE LINII:
                    console.log("=== RƒÇSPUNS DE LA SERVER ===");
                    console.log("Server response:", data);

                    addLogEntry('trainingLog', 'Training stopped', 'warning');

                    // ADAUGƒÇ ACESTE LINII:
                    setTimeout(() => {
                        console.log("=== DUPƒÇ STOP ===");
                        console.log("Accuracy dupƒÉ stop:", document.getElementById('modelAccuracy').textContent);
                        console.log("Epochs dupƒÉ stop:", document.getElementById('trainingEpochs').textContent);
                    }, 1000);
                });
        }

        // function startTrainingProgressSimulation() {
        //     let epoch = 0;
        //     const maxEpochs = 500;

        //     const progressInterval = setInterval(() => {
        //         if (!trainingActive) {
        //             clearInterval(progressInterval);
        //             return;
        //         }

        //         epoch++;
        //         const progress = (epoch / maxEpochs) * 100;
        //         document.getElementById('trainingProgressFill').style.width = Math.min(progress, 100) + '%';

        //         const baseAccuracy = Math.min(95, 20 + epoch * 0.15);
        //         const accuracy = baseAccuracy + (5 * (1 - 1 / (1 + epoch / 20))) + (Math.random() * 2 - 1);
        //         const finalAccuracy = Math.min(95, Math.max(20, accuracy));

        //         const baseLoss = Math.max(0.01, 2 - epoch * 0.004);
        //         const loss = baseLoss * (1 + (Math.random() * 0.1 - 0.05));

        //         trainingData.epochs.push(epoch);
        //         trainingData.accuracy.push(finalAccuracy);
        //         trainingData.loss.push(loss);

        //         document.getElementById('modelAccuracy').textContent = Math.round(finalAccuracy) + '%';
        //         document.getElementById('trainingEpochs').textContent = epoch;

        //         if (epoch % 5 === 0) {
        //             updateTrainingChart();
        //         }

        //         if (trainingData.epochs.length > 100) {
        //             trainingData.epochs = trainingData.epochs.slice(-100);
        //             trainingData.accuracy = trainingData.accuracy.slice(-100);
        //             trainingData.loss = trainingData.loss.slice(-100);
        //         }

        //     }, 200);
        // }

        function startTrainingProgressSimulation() {
            // NU mai generƒÉm valori locale - le luƒÉm de la backend
            const progressInterval = setInterval(() => {
                if (!trainingActive) {
                    clearInterval(progressInterval);
                    return;
                }

                // ActualizeazƒÉ din backend √Æn loc sƒÉ genereze local
                updateTrainingStatsFromBackend();

            }, 1000); // VerificƒÉ backend-ul la fiecare secundƒÉ
        }

        // NouƒÉ func»õie pentru a actualiza din backend
        function updateTrainingStatsFromBackend() {
            fetch('/api/training_stats')
                .then(response => response.json())
                .then(data => {
                    // Folose»ôte NUMAI valorile de la backend
                    const accuracy = data.accuracy || 0;
                    const epochs = data.epochs || 0;

                    // ActualizeazƒÉ UI-ul cu valorile reale din backend
                    document.getElementById('modelAccuracy').textContent = Math.round(accuracy) + '%';
                    document.getElementById('trainingEpochs').textContent = epochs;
                    document.getElementById('trainingSamples').textContent = `Training Samples: ${data.total_samples || 0}`;
                    document.getElementById('normalSamples').textContent = data.normal_samples || 0;
                    document.getElementById('attackSamples').textContent = data.attack_samples || 0;

                    // ActualizeazƒÉ progress bar bazat pe epoci
                    const maxEpochs = 500;
                    const progress = Math.min((epochs / maxEpochs) * 100, 100);
                    document.getElementById('trainingProgressFill').style.width = progress + '%';

                    // ActualizeazƒÉ datele pentru grafic DOAR cu valorile de la backend
                    if (data.training_metrics && data.training_metrics.accuracy) {
                        trainingData.epochs = data.training_metrics.epochs || [];
                        trainingData.accuracy = data.training_metrics.accuracy || [];
                        trainingData.loss = data.training_metrics.loss || [];

                        // ActualizeazƒÉ graficul cu datele reale
                        if (epochs % 5 === 0) {
                            updateTrainingChart();
                        }
                    }
                })
                .catch(error => {
                    console.log('Backend training stats failed:', error);
                });
        }

        function saveAIModels() {
            fetch('/api/save_ai_models')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        document.getElementById('trainingStatus').innerHTML = 'Status: <span style="color: #00b894;">Models Saved Successfully</span>';
                        addLogEntry('trainingLog', `${data.message}`, 'normal');
                    } else {
                        addLogEntry('trainingLog', `Error saving models: ${data.message}`, 'danger');
                    }
                });
        }

        function generateTrainingData(type) {
            addLogEntry('trainingLog', `Generating ${type} training data...`, 'normal');

            fetch(`/api/generate_training_data?type=${type}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        addLogEntry('trainingLog', `Generated ${data.count} ${type} samples`, 'normal');
                        updateTrainingStats();
                    } else {
                        addLogEntry('trainingLog', `Error: ${data.message}`, 'danger');
                    }
                })
                .catch((error) => {
                    console.log('Training data generation failed:', error);
                    // Fallback for demo purposes
                    const count = Math.floor(Math.random() * 500) + 100;
                    addLogEntry('trainingLog', `Generated ${count} ${type} samples (demo mode)`, 'normal');

                    const currentNormal = parseInt(document.getElementById('normalSamples').textContent) || 0;
                    const currentAttack = parseInt(document.getElementById('attackSamples').textContent) || 0;

                    if (type === 'normal') {
                        document.getElementById('normalSamples').textContent = currentNormal + count;
                    } else if (type === 'attack') {
                        document.getElementById('attackSamples').textContent = currentAttack + count;
                    } else if (type === 'mixed') {
                        document.getElementById('normalSamples').textContent = currentNormal + Math.floor(count * 0.7);
                        document.getElementById('attackSamples').textContent = currentAttack + Math.floor(count * 0.3);
                    }
                });
        }

        // Testing Functions
        function enableTesting() {
            if (trainingActive) {
                alert('Cannot enable testing while training is active! Stop training first.');
                return;
            }

            testingActive = true;
            updateModeIndicator();

            document.getElementById('enableTestingBtn').style.display = 'none';
            document.getElementById('disableTestingBtn').style.display = 'inline-block';
            document.getElementById('testingStatus').innerHTML = 'Status: <span style="color: #e74c3c;">Testing Mode Active</span>';

            fetch('/api/enable_testing_mode', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: true })
            })
                .then(response => response.json())
                .then(data => {
                    addLogEntry('defenseLog', 'Testing mode enabled - Defense systems online', 'normal');
                    // Reset testing statistics display
                    resetTestingDisplay();
                    // Sync blocked IPs after enabling testing
                    syncBlockedIPsDisplay();
                });
        }

        function disableTesting() {
            testingActive = false;
            updateModeIndicator();

            document.getElementById('enableTestingBtn').style.display = 'inline-block';
            document.getElementById('disableTestingBtn').style.display = 'none';
            document.getElementById('testingStatus').innerHTML = 'Status: <span style="color: #636e72;">Testing Mode Disabled</span>';

            document.getElementById('autoAttackToggle').checked = false;

            fetch('/api/enable_testing_mode', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: false })
            })
                .then(response => response.json())
                .then(data => {
                    addLogEntry('defenseLog', 'Testing mode disabled', 'warning');
                    // Sync blocked IPs after disabling testing
                    syncBlockedIPsDisplay();
                });
        }

        function resetTestingDisplay() {
            // Reset testing display values
            document.getElementById('totalAttacks').textContent = '0';
            document.getElementById('blockedAttacks').textContent = '0';
            document.getElementById('detectionRate').textContent = '0%';
            document.getElementById('lastAttackType').textContent = 'None';

            // Clear and update testing chart
            updateTestingChart();
        }

        function toggleAutoAttack() {
            if (!testingActive) {
                alert('Enable testing mode first!');
                document.getElementById('autoAttackToggle').checked = false;
                return;
            }

            const enabled = document.getElementById('autoAttackToggle').checked;

            fetch('/api/auto_attack', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: enabled, interval: 3 })
            })
                .then(response => response.json())
                .then(data => {
                    addLogEntry('defenseLog', `Auto attack ${enabled ? 'enabled' : 'disabled'}`, 'normal');
                });
        }

        function launchAttack(type = null) {
            if (!testingActive) {
                alert('Enable testing mode first!');
                return;
            }

            const url = type ? `/api/launch_attack?type=${type}` : '/api/launch_attack';

            fetch(url)
                .then(response => response.json())
                .then(data => {
                    addLogEntry('defenseLog', `Attack launched: ${data.attack.type}`, 'danger');

                    if (data.defense) {
                        addLogEntry('defenseLog', `Defense: ${data.defense.action} (${data.defense.threat_level})`,
                            data.defense.blocked ? 'danger' : 'warning');
                    }

                    updateTestingStats();
                    updateTestingChart();
                    // Sync blocked IPs after each attack to keep displays in sync
                    syncBlockedIPsDisplay();
                });
        }

        function resetTestResults() {
            fetch('/api/reset_test_results')
                .then(response => response.json())
                .then(data => {
                    addLogEntry('defenseLog', 'Test results reset', 'normal');
                    resetTestingDisplay();
                    updateTestingStats();
                    updateTestingChart();
                    // IMPORTANT: Sync blocked IPs after reset to update both testing and monitoring
                    syncBlockedIPsDisplay();
                });
        }

        // Monitoring Functions
        function startMonitoring() {
            fetch('/api/start_monitoring')
                .then(response => response.json())
                .then(data => {
                    addLogEntry('systemLog', data.message, 'normal');
                    updateSystemStatus();
                });
        }

        function stopMonitoring() {
            fetch('/api/stop_monitoring')
                .then(response => response.json())
                .then(data => {
                    addLogEntry('systemLog', data.message, 'warning');
                    updateSystemStatus();
                });
        }

        function resetSystem() {
            fetch('/api/reset_system')
                .then(response => response.json())
                .then(data => {
                    addLogEntry('systemLog', 'System reset completed', 'normal');

                    // Reset UI elements
                    document.getElementById('autoAttackToggle').checked = false;
                    document.getElementById('enableTestingBtn').style.display = 'inline-block';
                    document.getElementById('disableTestingBtn').style.display = 'none';
                    document.getElementById('trainingProgress').style.display = 'none';

                    // Reset training data
                    trainingData = { epochs: [], accuracy: [], loss: [] };

                    // Reset active states
                    trainingActive = false;
                    testingActive = false;
                    updateModeIndicator();

                    // Reset shared blocked IPs data
                    sharedBlockedIPs = {
                        total: 0,
                        recent: 0,
                        list: []
                    };

                    // Update all stats
                    updateStats();
                    syncBlockedIPsDisplay(); // Sync after system reset
                });
        }

        function updateBlockedIPs() {
            // This function is called from monitoring tab
            // But we use the shared sync function instead
            syncBlockedIPsDisplay();
        }

        // Utility Functions
        function addLogEntry(container, message, type = 'normal') {
            const logContainer = document.getElementById(container);
            if (!logContainer) return;

            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.innerHTML = `[${new Date().toLocaleTimeString()}] ${message}`;

            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;

            while (logContainer.children.length > 50) {
                logContainer.removeChild(logContainer.firstChild);
            }
        }

        function updateSystemStatus() {
            fetch('/api/system_status')
                .then(response => response.json())
                .then(data => {
                    const monitorStatus = document.getElementById('monitorStatus');
                    if (monitorStatus) {
                        monitorStatus.className = data.monitoring ? 'status-indicator status-active' : 'status-indicator status-inactive';
                    }

                    // Update active states from server
                    trainingActive = data.training_mode && data.training_in_progress;
                    testingActive = data.testing_mode;
                    updateModeIndicator();
                })
                .catch(error => console.log('Status update failed:', error));
        }

        function updateStats() {
            if (currentTab === 'training') {
                updateTrainingStats();
            } else if (currentTab === 'testing') {
                updateTestingStats();
                // Always sync blocked IPs when updating testing stats
                syncBlockedIPsDisplay();
            } else if (currentTab === 'monitoring') {
                updateMonitoringStats();
                // Monitoring stats include blocked IPs sync automatically
            }
        }

        // function updateTrainingStats() {
        //     fetch('/api/training_stats')
        //         .then(response => response.json())
        //         .then(data => {
        //             console.log("=== API TRAINING STATS ===");
        //             console.log("API response:", data);
        //             console.log("API accuracy:", data.accuracy);
        //             console.log("API epochs:", data.epochs);
        //             console.log("Current UI accuracy:", document.getElementById('modelAccuracy').textContent);
        //             console.log("Current UI epochs:", document.getElementById('trainingEpochs').textContent);
        //             document.getElementById('trainingSamples').textContent = `Training Samples: ${data.total_samples || 0}`;
        //             document.getElementById('normalSamples').textContent = data.normal_samples || 0;
        //             document.getElementById('attackSamples').textContent = data.attack_samples || 0;

        //             if (!trainingActive) {
        //                 document.getElementById('modelAccuracy').textContent = `${data.accuracy || 0}%`;
        //                 document.getElementById('trainingEpochs').textContent = data.epochs || 0;
        //             }
        //         })
        //         .catch(error => console.log('Training stats failed:', error));
        // }
        function updateTrainingStats() {
            fetch('/api/training_stats')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('trainingSamples').textContent = `Training Samples: ${data.total_samples || 0}`;
                    document.getElementById('normalSamples').textContent = data.normal_samples || 0;
                    document.getElementById('attackSamples').textContent = data.attack_samples || 0;

                    // √éNTOTDEAUNA folose»ôte valorile de la backend
                    document.getElementById('modelAccuracy').textContent = `${Math.round(data.accuracy || 0)}%`;
                    document.getElementById('trainingEpochs').textContent = data.epochs || 0;

                    // ActualizeazƒÉ datele locale pentru grafic
                    if (data.training_metrics) {
                        trainingData.epochs = data.training_metrics.epochs || [];
                        trainingData.accuracy = data.training_metrics.accuracy || [];
                        trainingData.loss = data.training_metrics.loss || [];
                        updateTrainingChart();
                    }
                })
                .catch(error => console.log('Training stats failed:', error));
        }
        function updateTestingStats() {
            if (!testingActive) return;

            // Get attack statistics (testing-specific)
            fetch('/api/attack_stats')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('totalAttacks').textContent = data.total_attacks || 0;
                    document.getElementById('lastAttackType').textContent =
                        data.last_attack ? data.last_attack.type : 'None';
                })
                .catch(error => console.log('Attack stats failed:', error));

            // Get defense statistics (testing-specific) including synced blocked count
            fetch('/api/defense_stats')
                .then(response => response.json())
                .then(data => {
                    // Use actual blocked IPs count (synced with monitoring)
                    const blockedAttacks = data.total_blocked_ips || 0;
                    document.getElementById('blockedAttacks').textContent = blockedAttacks;

                    // Calculate detection rate from testing data
                    const totalAttacks = parseInt(document.getElementById('totalAttacks').textContent) || 0;
                    let detectionRate = 0;
                    if (totalAttacks > 0) {
                        detectionRate = Math.round((blockedAttacks / totalAttacks) * 100);
                    }
                    document.getElementById('detectionRate').textContent = `${detectionRate}%`;
                })
                .catch(error => console.log('Defense stats failed:', error));
        }

        function updateMonitoringStats() {
            // Use the new monitoring-specific endpoint that syncs with testing
            fetch('/api/monitoring_stats')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('totalPackets').textContent = data.total_packets || 0;
                    document.getElementById('totalBlockedIPs').textContent = data.total_blocked_ips || 0;
                    document.getElementById('recentBlocks').textContent = data.recent_blocks || 0;

                    // Update anomalies counter
                    if (data.total_anomalies !== undefined) {
                        anomalyCount = data.total_anomalies;
                        document.getElementById('anomalies').textContent = anomalyCount;
                    }

                    // Update blocked IPs list with synced data
                    updateBlockedIPsInMonitoring({
                        blocked_ips: data.blocked_ips_list || [],
                        total_blocked: data.total_blocked_ips || 0
                    });
                })
                .catch(error => {
                    console.log('Monitoring stats failed:', error);
                    // Fallback to old method
                    fetch('/api/network_stats')
                        .then(response => response.json())
                        .then(data => {
                            document.getElementById('totalPackets').textContent = data.stats.total_packets || 0;
                        })
                        .catch(error => console.log('Network stats failed:', error));
                });

            // Check for new anomalies
            fetch('/api/detect_anomaly')
                .then(response => response.json())
                .then(data => {
                    if (data.anomaly_detected) {
                        addLogEntry('systemLog', `Anomaly detected! Confidence: ${data.confidence.toFixed(2)}`, 'danger');
                    }
                    if (data.total_anomalies !== undefined) {
                        anomalyCount = data.total_anomalies;
                        document.getElementById('anomalies').textContent = anomalyCount;
                    }
                })
                .catch(error => console.log('Anomaly detection failed:', error));
        }

        function updateTrainingChart() {
            if (trainingData.epochs.length === 0) return;

            const trace1 = {
                x: trainingData.epochs,
                y: trainingData.accuracy,
                type: 'scatter',
                mode: 'lines',
                name: 'Accuracy (%)',
                line: { color: '#00b894', width: 3 }
            };

            const trace2 = {
                x: trainingData.epochs,
                y: trainingData.loss,
                type: 'scatter',
                mode: 'lines',
                name: 'Loss',
                yaxis: 'y2',
                line: { color: '#ff6b6b', width: 3 }
            };

            const layout = {
                title: {
                    text: 'Training Progress',
                    font: { color: 'white', size: 16 }
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0.2)',
                font: { color: 'white' },
                xaxis: {
                    color: 'white',
                    title: 'Epochs',
                    gridcolor: 'rgba(255,255,255,0.1)'
                },
                yaxis: {
                    color: 'white',
                    title: 'Accuracy (%)',
                    range: [0, 100],
                    gridcolor: 'rgba(255,255,255,0.1)'
                },
                yaxis2: {
                    title: 'Loss',
                    titlefont: { color: '#ff6b6b' },
                    tickfont: { color: '#ff6b6b' },
                    overlaying: 'y',
                    side: 'right',
                    range: [0, 2]
                },
                legend: {
                    font: { color: 'white' }
                },
                margin: { t: 50, b: 50, l: 50, r: 50 }
            };

            Plotly.newPlot('trainingChart', [trace1, trace2], layout, { responsive: true });
        }

        function updateTestingChart() {
            if (!testingActive) {
                // Show placeholder chart when not in testing mode
                const layout = {
                    title: 'Attack Detection Results',
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: 'rgba(0,0,0,0.2)',
                    font: { color: 'white' },
                    xaxis: { color: 'white' },
                    yaxis: { color: 'white' },
                    annotations: [{
                        text: 'Enable Testing Mode to View Results',
                        xref: 'paper',
                        yref: 'paper',
                        x: 0.5,
                        y: 0.5,
                        xanchor: 'center',
                        yanchor: 'center',
                        showarrow: false,
                        font: { color: 'white', size: 16 }
                    }],
                    margin: { t: 50, b: 80, l: 50, r: 20 }
                };
                Plotly.newPlot('testingChart', [], layout, { responsive: true });
                return;
            }

            // Get real testing chart data from server
            fetch('/api/testing_chart_data')
                .then(response => response.json())
                .then(result => {
                    if (result.success && result.data && result.data.categories.length > 0) {
                        const data = result.data;

                        const trace1 = {
                            x: data.categories,
                            y: data.detected,
                            name: 'Detected (%)',
                            type: 'bar',
                            marker: { color: '#00b894' }
                        };

                        const trace2 = {
                            x: data.categories,
                            y: data.missed,
                            name: 'Missed (%)',
                            type: 'bar',
                            marker: { color: '#ff6b6b' }
                        };

                        const layout = {
                            title: 'Attack Detection Results (%)',
                            paper_bgcolor: 'rgba(0,0,0,0)',
                            plot_bgcolor: 'rgba(0,0,0,0.2)',
                            font: { color: 'white' },
                            xaxis: {
                                color: 'white',
                                tickangle: -45,
                                automargin: true
                            },
                            yaxis: {
                                color: 'white',
                                range: [0, 100],
                                title: 'Percentage (%)'
                            },
                            barmode: 'stack',
                            legend: {
                                font: { color: 'white' },
                                orientation: 'h',
                                x: 0.5,
                                xanchor: 'center',
                                y: -0.2
                            },
                            margin: { t: 50, b: 100, l: 50, r: 20 }
                        };

                        Plotly.newPlot('testingChart', [trace1, trace2], layout, { responsive: true });
                    } else {
                        // Show default chart with all attack types but no data yet
                        const allAttackTypes = ['DDoS', 'Port Scan', 'Brute Force', 'SQL Injection', 'XSS', 'Malware', 'Phishing', 'Man-in-Middle'];
                        const detectedData = new Array(allAttackTypes.length).fill(0);
                        const missedData = new Array(allAttackTypes.length).fill(0);

                        const trace1 = {
                            x: allAttackTypes,
                            y: detectedData,
                            name: 'Detected (%)',
                            type: 'bar',
                            marker: { color: '#00b894' }
                        };

                        const trace2 = {
                            x: allAttackTypes,
                            y: missedData,
                            name: 'Missed (%)',
                            type: 'bar',
                            marker: { color: '#ff6b6b' }
                        };

                        const layout = {
                            title: 'Attack Detection Results (%) - No attacks tested yet',
                            paper_bgcolor: 'rgba(0,0,0,0)',
                            plot_bgcolor: 'rgba(0,0,0,0.2)',
                            font: { color: 'white' },
                            xaxis: {
                                color: 'white',
                                tickangle: -45,
                                automargin: true
                            },
                            yaxis: {
                                color: 'white',
                                range: [0, 100],
                                title: 'Percentage (%)'
                            },
                            barmode: 'stack',
                            legend: {
                                font: { color: 'white' },
                                orientation: 'h',
                                x: 0.5,
                                xanchor: 'center',
                                y: -0.2
                            },
                            margin: { t: 50, b: 100, l: 50, r: 20 }
                        };

                        Plotly.newPlot('testingChart', [trace1, trace2], layout, { responsive: true });
                    }
                })
                .catch(error => {
                    console.log('Testing chart update failed, showing default chart:', error);
                    // Fallback - show all attack types with zero data
                    const allAttackTypes = ['DDoS', 'Port Scan', 'Brute Force', 'SQL Injection', 'XSS', 'Malware', 'Phishing', 'Man-in-Middle'];
                    const detectedData = new Array(allAttackTypes.length).fill(0);
                    const missedData = new Array(allAttackTypes.length).fill(0);

                    const trace1 = {
                        x: allAttackTypes,
                        y: detectedData,
                        name: 'Detected (%)',
                        type: 'bar',
                        marker: { color: '#00b894' }
                    };

                    const trace2 = {
                        x: allAttackTypes,
                        y: missedData,
                        name: 'Missed (%)',
                        type: 'bar',
                        marker: { color: '#ff6b6b' }
                    };

                    const layout = {
                        title: 'Attack Detection Results (%) - Connecting to server...',
                        paper_bgcolor: 'rgba(0,0,0,0)',
                        plot_bgcolor: 'rgba(0,0,0,0.2)',
                        font: { color: 'white' },
                        xaxis: {
                            color: 'white',
                            tickangle: -45,
                            automargin: true
                        },
                        yaxis: {
                            color: 'white',
                            range: [0, 100],
                            title: 'Percentage (%)'
                        },
                        barmode: 'stack',
                        legend: {
                            font: { color: 'white' },
                            orientation: 'h',
                            x: 0.5,
                            xanchor: 'center',
                            y: -0.2
                        },
                        margin: { t: 50, b: 100, l: 50, r: 20 }
                    };

                    Plotly.newPlot('testingChart', [trace1, trace2], layout, { responsive: true });
                });
        }

        function updateSystemStatsChart() {
            // Create a simple chart showing system stats over time
            const timeNow = new Date();
            const times = [];
            const packets = [];
            const blocks = [];

            for (let i = 19; i >= 0; i--) {
                times.push(new Date(timeNow.getTime() - i * 10000)); // 10 second intervals
                packets.push(Math.random() * 100 + 50);
                blocks.push(Math.random() * 10);
            }

            const trace1 = {
                x: times,
                y: packets,
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Packets/sec',
                line: { color: '#74b9ff' }
            };

            const trace2 = {
                x: times,
                y: blocks,
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Blocked IPs',
                yaxis: 'y2',
                line: { color: '#ff6b6b' }
            };

            const layout = {
                title: 'Network Activity',
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0.2)',
                font: { color: 'white' },
                xaxis: {
                    color: 'white',
                    type: 'date'
                },
                yaxis: {
                    color: 'white',
                    title: 'Packets/sec'
                },
                yaxis2: {
                    title: 'Blocked IPs',
                    titlefont: { color: '#ff6b6b' },
                    tickfont: { color: '#ff6b6b' },
                    overlaying: 'y',
                    side: 'right'
                },
                legend: {
                    font: { color: 'white' }
                },
                margin: { t: 50, b: 50, l: 50, r: 50 }
            };

            Plotly.newPlot('systemStatsChart', [trace1, trace2], layout, { responsive: true });
        }

        // Initialize dashboard
        document.addEventListener('DOMContentLoaded', function () {
            updateSystemStatus();
            updateStats();
            updateModeIndicator();

            // Initial sync of blocked IPs
            syncBlockedIPsDisplay();

            updateTrainingChart();
            updateTestingChart();
            updateSystemStatsChart();

            // Set up periodic updates
            updateInterval = setInterval(() => {
                updateSystemStatus();

                if (currentTab === 'training') {
                    updateTrainingStats();
                } else if (currentTab === 'testing') {
                    updateTestingStats();
                    if (testingActive) {
                        updateTestingChart(); // Update chart more frequently in testing mode
                        syncBlockedIPsDisplay(); // Keep blocked IPs synced during testing
                    }
                } else if (currentTab === 'monitoring') {
                    updateMonitoringStats();
                    updateSystemStatsChart();
                    // Monitoring stats update includes blocked IPs sync automatically
                }

                // Always sync blocked IPs every update cycle to ensure consistency
                if (testingActive || currentTab === 'monitoring') {
                    syncBlockedIPsDisplay();
                }
            }, 3000);
        });
    </script>
</body>

</html>